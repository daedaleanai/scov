package main

import (
	"io"
	"sort"
	"text/template"
	"time"
)

var (
	mdtmpltop = template.New("markdown")
	_         = template.Must(mdtmpltop.New("coverageRow").Parse(
		`{{.Hits}} | {{.Total}} | {{printf "%.1f" .P}}%`,
	))
	_ = template.Must(mdtmpltop.New("coverageDetail").Parse(
		`{{if .Valid}} {{.Hits}}/{{.Total}} ({{printf "%.1f" .P}}%) {{else}} No Data {{end}}`,
	))
	_ = template.Must(mdtmpltop.New("footer").Parse(
		`***
Generated by [SCov](https://gitlab.com/stone.code/scov).
`,
	))
	mdtmpl = template.Must(mdtmpltop.New("markdown").Parse(
		`# {{.Title}}

## Metadata

{{ if or .SrcID .TestID .Filename -}}
|       |       |
| :---- | :---- |
| Date: | {{.Date }} |
{{ if .SrcID -}}
| Source ID: | {{.SrcID}} |
{{ end -}}
{{ if .TestID -}}
| Test ID: | {{.TestID}} |
{{ end -}}
{{ if .Filename -}}
| Filename: | {{.Filename}} |
{{ end -}}
{{- else -}}
Date: {{.Date}}
{{ end }}

## Coverage Summary

|        | Hits   | Total  | Coverage |
| :----- | :----: | :----: | :------: |
| Lines: | {{template "coverageRow" .LCoverage}} |
{{ if .FCoverage.Valid -}}
| Functions: | {{template "coverageRow" .FCoverage}} |
{{ end -}}
{{ if .BCoverage.Valid -}}
| Branches: | {{template "coverageRow" .BCoverage}} |
{{ end }}

## By File

{{ $useFunc := .FCoverage.Valid -}}
{{ $useBranch := .BCoverage.Valid -}}
| Filename | Line Coverage |{{if $useFunc }} Function Coverage |{{end}}{{if $useBranch}} Branch Coverage |{{end}}
| :------- | :-----------: |{{if $useFunc }} :---------------: |{{end}}{{if $useBranch}} :-------------: |{{end}}
{{range $ndx, $data := .Files -}}
| {{.Name}} |{{template "coverageDetail" .LCoverage}} 
{{- if $useFunc -}}
|{{template "coverageDetail" .FCoverage}} 
{{- end -}}
{{- if $useBranch -}}
|{{template "coverageDetail" .BCoverage}} 
{{- end -}}
|
{{ end }}

## By Function

| Function | Hits |
| :------- | :--: |
{{range $ndx, $data := .Funcs -}}
| {{.Name}} | {{.HitCount }} |
{{ end }}

{{ template "footer" }}
`,
	))
)

func createMarkdownReport(filename string, data map[string]*FileData, date time.Time) error {
	w, err := Open(filename)
	if err != nil {
		return err
	}
	defer w.Close()

	err = writeMarkdownReport(w.File(), data, date)
	w.Keep(err)
	return err
}

func writeMarkdownReport(writer io.Writer, data map[string]*FileData, date time.Time) error {
	LCov := Coverage{}
	FCov := Coverage{}
	BCov := Coverage{}
	files := []FileStatistics{}
	funcs := []FuncStatistic{}
	for filename, data := range data {
		stats := FileStatistics{Name: filename}

		stats.LCoverage = data.LineCoverage()
		LCov = LCov.Add(stats.LCoverage)
		stats.FCoverage = data.FuncCoverage()
		FCov = FCov.Add(stats.FCoverage)
		stats.BCoverage = data.BranchCoverage()
		BCov = BCov.Add(stats.BCoverage)

		files = append(files, stats)

		for name, data := range data.FuncData {
			funcs = append(funcs, FuncStatistic{
				Name:      name,
				Filename:  filename,
				StartLine: data.StartLine,
				HitCount:  data.HitCount,
			})
		}
	}
	sort.Slice(files, func(i, j int) bool {
		return files[i].Name < files[j].Name
	})
	sort.Slice(funcs, func(i, j int) bool {
		return funcs[i].Name < funcs[j].Name
	})

	params := map[string]interface{}{
		"Title":      *title,
		"SrcID":      *srcid,
		"TestID":     *testid,
		"ProjectURL": *projecturl,
		"LCoverage":  LCov,
		"FCoverage":  FCov,
		"BCoverage":  BCov,
		"Files":      files,
		"Funcs":      funcs,
		"Date":       date.Format(time.UnixDate),
		"Script":     *htmljs,
	}

	return mdtmpl.Execute(writer, params)
}
